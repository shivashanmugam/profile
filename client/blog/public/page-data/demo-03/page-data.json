{"componentChunkName":"component---src-templates-post-js","path":"/demo-03","result":{"data":{"site":{"siteMetadata":{"title":"Blog üè°","description":"This is where they post things!","author":{"name":"Siva Kannan"},"keywords":["Video Blogger"]}},"mdx":{"frontmatter":{"title":"Design pattern","date":"May 07, 2019","author":null,"banner":null,"slug":"design-pattern","keywords":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nconst _frontmatter = {\n  \"slug\": \"design-pattern\",\n  \"date\": \"2019-05-07T00:00:00.000Z\",\n  \"title\": \"Design pattern\",\n  \"description\": \"Generator function in javascript, What is it, Working mechanism, Why we need it ? Multiple use cases\",\n  \"published\": true\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", props);\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, `Design Patterns`), mdx(\"p\", null, `===============\nThere‚Äôs been a ton of articles on design patterns. This article emphasis more on why should we use it first of all.`), mdx(\"h2\", null, `What is design pattern ?`), mdx(\"p\", null, `There is a lot of ways to write code for a single solution. But some ways has been used by many developers and they iterated it over a period and optimized in a best possible way so that the code is reusable and easy to use. The each proven way of writing code is called a design pattern.`), mdx(\"h3\", null, `Why to use design pattern ? ( Advantages )`), mdx(\"hr\", null), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, `The design patterns will be helpful in the approach of solving different problems.`), mdx(\"li\", {\n    parentName: \"ol\"\n  }, `When developers in the same codebase starts using design pattern it helps the team to understand effortlessly what the code trying to express irrespective of who written it. The communication between the developers will be seamless if the developers becomes familiar with design patterns while solving a problem.`), mdx(\"li\", {\n    parentName: \"ol\"\n  }, `While writing code by keeping design patterns in mind we more likely to write optimized code. This prevents us from refactoring the code.`)), mdx(\"h3\", null, `How it makes the code more readable and reusable`), mdx(\"hr\", null), mdx(\"p\", null, `There is design pattern called `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Iterator design pattern`), `. Most of them are using it without realizing it. Because it is widely adopted by developers.`), mdx(\"h3\", null, `Without iterator pattern`), mdx(\"p\", null, `The below Programs Motive is `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `Adding tax for all the items`), ` `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `cost`)), mdx(\"p\", null, `In the above code we iterated through all the items by a new variable `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, `i`)), `. For the iteration  to work fine we need to take care two things in the `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, `addTax`)), ` function‚Äôs `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, `for loop`)), `.`), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Increment`), ` - Ensure `, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, `i`)), ` is incremented after performing operation on each item. `, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `( i++)`)), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Condition`), ` - Ensure the iteration is not infinite by limiting to total items. `, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `( i < items.length )`))), mdx(\"p\", null, `This kind of coding pattern we very often encounter. Is there anything we can do to make it better. Let‚Äôs discuss.`), mdx(\"p\", null, `The `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `addTax`), ` function focuses more on `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `How to do`), ` rather than `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `What to do.`), ` The function motive is to just add the tax for all items present. But the code also focuses more on picking items one by one.`), mdx(\"p\", null, `Let‚Äôs create a iterator which emphasis on `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `What to do`), ` and eliminates most of the `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `How to do`), ` (Increment and Condition) part.`), mdx(\"h4\", null, `With Iterator Pattern`), mdx(\"p\", null, `The above code eliminated the `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `How to do`), ` part by introducing a new Iterator class.`), mdx(\"p\", null, `The above iterator design pattern was one of the highly used design pattern in javacript. Then later `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `ecmascript ( javascript )`), ` officially adopted this pattern in it‚Äôs language for Arrays during it‚Äôs 2015 documentation ( `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `ES6`), ` ). After ES6 we don‚Äôt need the `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, `Iterator class`)), ` at all. The Array Object comes with a `, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `forEach`), ` iterator.`), mdx(\"p\", null, `I guess the walk through helps us to understand How design patterns emerges and why we should use design pattern.`));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"fd3e98ec-27a6-5568-ac1b-28cbf3cabe71","prev":null,"next":{"id":"196b5e4c-c318-54b3-94bd-ea1bccd1c148","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"Generator Function They‚Äôre especially good for working with multiple asynchronous steps Before we see fully about generator function let's understand a scenario why and when we need a generator function Pseduo Scenario We need to get first ninja's‚Ä¶","fields":{"title":"Generator Function Javascript","slug":"demo-02","date":"2018-01-01T00:00:00.000Z"}}}}}